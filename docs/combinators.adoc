= Available combinators and how to use them
:hardbreaks-option:

A glossary of all combinators available within `chomp` and their intended use.

== Basic combinators

TODO

[%header,cols="1a,1a,1a"]
|===
|Combinator
|Usage
|Output

|
https://pkg.go.dev/github.com/purpleclay/chomp#Tag:[Tag]

Must match a series of characters at the beginning of the input text, in the exact order and case provided
|
[source,go]
----
chomp.Tag("Hello")("Hello, World!")
----
|
....
rem: ", World!"
ext: "Hello"
....

|
https://pkg.go.dev/github.com/purpleclay/chomp#Any:[Any]

Must match at least one character at the beginning of the input text, from the provided sequence. Parsing immediately stops upon the first unmatched character
|
[source,go]
----
chomp.Any("eH")("Hello, World!")
----
|
....
rem: "llo, World!"
ext: "He"
....

|
https://pkg.go.dev/github.com/purpleclay/chomp#Not:[Not]

Must not match at least one character at the beginning of the input text from the provided sequence. Parsing immediately stops upon the first matched character
|
[source,go]
----
chomp.Not("ol")("Hello, World!")
----
|
....
rem: "llo, World!"
ext: "He"
....

|
https://pkg.go.dev/github.com/purpleclay/chomp#Crlf:[Crlf]

Must match either a `CR (\r)` or `CRLF (\r\n)` line ending
|
[source,go]
----
chomp.Crlf()("\r\nHello")
----
|
....
rem: "Hello"
ext: "\r\n"
....

|
https://pkg.go.dev/github.com/purpleclay/chomp#OneOf:[OneOf]

Must match a single character at the beginning of the text from the provided sequence
|
[source,go]
----
chomp.OneOf("!,eH")("Hello, World!")
----
|
....
rem: "ello, World!"
ext: "H"
....

|
https://pkg.go.dev/github.com/purpleclay/chomp#NoneOf:[NoneOf]

Must not match a single character at the beginning of the text from the provided sequence
|
[source,go]
----
chomp.NoneOf("loWrd!e")("Hello, World!")
----
|
....
rem: "ello, World!"
ext: "H"
....

|
https://pkg.go.dev/github.com/purpleclay/chomp#Until:[Until]

Will scan the input text for the first occurrence of the provided series of characters. Everything until that point in the text will be matched
|
[source,go]
----
chomp.Until("World")("Hello, World!")
----
|
....
rem: "World!"
ext: "Hello, "
....

|
https://pkg.go.dev/github.com/purpleclay/chomp#Eol:[Eol]

Will scan the text until it encounters any ASCII line ending characters identified by the [IsLineEnding] predicate. All text before the line ending will be returned. The line ending, if detected, will be discarded
|
[source,go]
----
chomp.Eol()(`Hello, World!\nIt's a great day!`)
----
|
....
rem: "It's a great day!"
ext: "Hello, World!"
....
|===

== Predicate combinators

TODO

[%header,cols="1a,1a,1a"]
|===
|Combinator
|Usage
|Output

|
https://pkg.go.dev/github.com/purpleclay/chomp#While:[While]

Will scan the input text, testing each character against the provided predicate. Everything until the predicate returns false will be matched. A minimum of one character must be returned
|
[source,go]
----
chomp.While(chomp.IsLetter)("Hello, World!")
----
|
....
rem: ", World!"
ext: "Hello"
....

|
https://pkg.go.dev/github.com/purpleclay/chomp#WhileN:[WhileN]

Will scan the input text, testing each character against the provided predicate. Everything until the predicate returns false will be matched. A minimum of `n` characters must be returned. If `n` is zero, this becomes an [.underline]#optional combinator#
|
[source,go]
----
chomp.WhileN(chomp.IsLetter, 1)("Hello, World!")
----
|
....
rem: ", World!"
ext: "Hello"
....

|
https://pkg.go.dev/github.com/purpleclay/chomp#WhileNM:[WhileNM]

Will scan the input text, testing each character against the provided predicate. Everything until the predicate returns false will be matched. A minimum of `n` and upto a maximum of `m` characters must be returned. If `n` is zero, this becomes an [.underline]#optional combinator#
|
[source,go]
----
chomp.WhileNM(chomp.IsLetter, 1, 8)("Hello, World!")
----
|
....
rem: ", World!"
ext: "Hello"
....

|
https://pkg.go.dev/github.com/purpleclay/chomp#WhileNot:[WhileNot]

Will scan the input text, testing each character against the provided predicate. Everything until the predicate returns true will be matched. This is the inverse of [While]. A minimum of one character must be returned.
|
[source,go]
----
chomp.WhileNot(chomp.IsDigit)("Hello, World!")
----
|
....
rem: ""
ext: "Hello, World!"
....

|
https://pkg.go.dev/github.com/purpleclay/chomp#WhileNotN:[WhileNotN]

Will scan the input text, testing each character against the provided predicate. Everything until the predicate returns true will be matched. This is the inverse of [WhileN]. A minimum of `n` characters must be returned. If `n` is zero, this becomes an optional combinator
|
[source,go]
----
chomp.WhileNotN(chomp.IsDigit, 1)("Hello, World!")
----
|
....
rem: ""
ext: "Hello, World!"
....

|
https://pkg.go.dev/github.com/purpleclay/chomp#WhileNotNM:[WhileNotNM]

Will scan the input text, testing each character against the provided predicate. Everything until the predicate returns true will be matched. This is the inverse of [WhileNM]. A minimum of `n` and upto a maximum of `m` characters must be returned. If `n` is zero, this becomes an optional combinator
|
[source,go]
----
chomp.WhileNotNM(
  chomp.IsLetter, 1, 8,
)("20240709 was a great day")
----
|
....
rem: " was a great day"
ext: "20240709"
....
|===

== Sequence combinators

TODO
