= Available combinators and how to use them
:hardbreaks-option:
:table-stripes: none

A glossary of all combinators available within `chomp` and their intended use.

== Basic combinators

TODO

[%header,cols="1a,1a,1a"]
|===
|Combinator
|Usage
|Output

|
https://pkg.go.dev/github.com/purpleclay/chomp#Tag:[Tag]
Must match a series of characters at the beginning of the input text, in the exact order and case provided
|
[source,go]
----
chomp.Tag("Hello")("Hello, World!")
----
|
....
rem: ", World!"
ext: "Hello"
....

|
https://pkg.go.dev/github.com/purpleclay/chomp#Any:[Any]
Must match at least one character at the beginning of the input text, from the provided sequence. Parsing immediately stops upon the first unmatched character
|
[source,go]
----
chomp.Any("eH")("Hello, World!")
----
|
....
rem: "llo, World!"
ext: "He"
....

|
https://pkg.go.dev/github.com/purpleclay/chomp#Not:[Not]
Must not match at least one character at the beginning of the input text from the provided sequence. Parsing immediately stops upon the first matched character
|
[source,go]
----
chomp.Not("ol")("Hello, World!")
----
|
....
rem: "llo, World!"
ext: "He"
....

|
https://pkg.go.dev/github.com/purpleclay/chomp#Crlf:[Crlf]
Must match either a `CR (\r)` or `CRLF (\r\n)` line ending
|
[source,go]
----
chomp.Crlf()("\r\nHello")
----
|
....
rem: "Hello"
ext: "\r\n"
....

|
https://pkg.go.dev/github.com/purpleclay/chomp#OneOf:[OneOf]
Must match a single character at the beginning of the text from the provided sequence
|
[source,go]
----
chomp.OneOf("!,eH")("Hello, World!")
----
|
....
rem: "ello, World!"
ext: "H"
....

|
https://pkg.go.dev/github.com/purpleclay/chomp#NoneOf:[NoneOf]
Must not match a single character at the beginning of the text from the provided sequence
|
[source,go]
----
chomp.NoneOf("loWrd!e")("Hello, World!")
----
|
....
rem: "ello, World!"
ext: "H"
....

|
https://pkg.go.dev/github.com/purpleclay/chomp#Until:[Until]
Will scan the input text for the first occurrence of the provided series of characters. Everything until that point in the text will be matched
|
[source,go]
----
chomp.Until("World")("Hello, World!")
----
|
....
rem: "World!"
ext: "Hello, "
....

|
https://pkg.go.dev/github.com/purpleclay/chomp#Eol:[Eol]
Will scan the text until it encounters any ASCII line ending characters identified by the [IsLineEnding] predicate. All text before the line ending will be returned. The line ending, if detected, will be discarded
|
[source,go]
----
chomp.Eol()(`Hello, World!\nIt's a great day!`)
----
|
....
rem: "It's a great day!"
ext: "Hello, World!"
....
|===

== Predicate combinators

TODO

[%header,cols="1a,1a,1a"]
|===
|Combinator
|Usage
|Output

|https://pkg.go.dev/github.com/purpleclay/chomp#While:[While]
|
[source,go]
----
chomp.While(chomp.IsLetter)("Hello, World!")
----
|
....
rem:
ext:
....

|https://pkg.go.dev/github.com/purpleclay/chomp#WhileN:[WhileN]
|
[source,go]
----
chomp.WhileN(chomp.IsLetter, 1)("Hello, World!")
----
|
....
rem:
ext:
....

|https://pkg.go.dev/github.com/purpleclay/chomp#WhileNM:[WhileNM]
|
[source,go]
----
chomp.WhileNM(chomp.IsLetter, 1, 8)("Hello, World!")
----
|
....
rem:
ext:
....

|https://pkg.go.dev/github.com/purpleclay/chomp#WhileNot:[WhileNot]
|
[source,go]
----
chomp.WhileNot(chomp.IsDigit)("Hello, World!")
----
|
....
rem:
ext:
....

|https://pkg.go.dev/github.com/purpleclay/chomp#WhileNotN:[WhileNotN]
|
[source,go]
----
chomp.WhileNotN(chomp.IsDigit, 1)("Hello, World!")
----
|
....
rem:
ext:
....

|https://pkg.go.dev/github.com/purpleclay/chomp#WhileNotNM:[WhileNotNM]
|
[source,go]
----
chomp.WhileNotNM(chomp.IsLetter, 1, 8)("20240709 was a great day")
----
|
....
rem:
ext:
....
|===

== Sequence combinators

TODO
