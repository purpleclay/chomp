= Available combinators and how to use them
:hardbreaks-option:

A glossary of all combinators available within `chomp` and their intended use.

== Basic combinators

TODO

[%header,cols="1a,1a,1a"]
|===
|Combinator
|Usage
|Output

|
https://pkg.go.dev/github.com/purpleclay/chomp#Tag[Tag]

Must match a series of characters at the beginning of the input text, in the exact order and case provided
|
[source,go]
----
chomp.Tag("Hello")("Hello, World!")
----
|
....
rem: ", World!"
ext: "Hello"
....

|
https://pkg.go.dev/github.com/purpleclay/chomp#Any[Any]

Must match at least one character at the beginning of the input text, from the provided sequence. Parsing immediately stops upon the first unmatched character
|
[source,go]
----
chomp.Any("eH")("Hello, World!")
----
|
....
rem: "llo, World!"
ext: "He"
....

|
https://pkg.go.dev/github.com/purpleclay/chomp#Not[Not]

Must not match at least one character at the beginning of the input text from the provided sequence. Parsing immediately stops upon the first matched character
|
[source,go]
----
chomp.Not("ol")("Hello, World!")
----
|
....
rem: "llo, World!"
ext: "He"
....

|
https://pkg.go.dev/github.com/purpleclay/chomp#Crlf[Crlf]

Must match either a `CR (\r)` or `CRLF (\r\n)` line ending
|
[source,go]
----
chomp.Crlf()("\r\nHello")
----
|
....
rem: "Hello"
ext: "\r\n"
....

|
https://pkg.go.dev/github.com/purpleclay/chomp#OneOf[OneOf]

Must match a single character at the beginning of the text from the provided sequence
|
[source,go]
----
chomp.OneOf("!,eH")("Hello, World!")
----
|
....
rem: "ello, World!"
ext: "H"
....

|
https://pkg.go.dev/github.com/purpleclay/chomp#NoneOf[NoneOf]

Must not match a single character at the beginning of the text from the provided sequence
|
[source,go]
----
chomp.NoneOf("loWrd!e")("Hello, World!")
----
|
....
rem: "ello, World!"
ext: "H"
....

|
https://pkg.go.dev/github.com/purpleclay/chomp#Until[Until]

Will scan the input text for the first occurrence of the provided series of characters. Everything until that point in the text will be matched
|
[source,go]
----
chomp.Until("World")("Hello, World!")
----
|
....
rem: "World!"
ext: "Hello, "
....

|
https://pkg.go.dev/github.com/purpleclay/chomp#Eol[Eol]

Will scan the text until it encounters any ASCII line ending characters identified by the [IsLineEnding] predicate. All text before the line ending will be returned. The line ending, if detected, will be discarded
|
[source,go]
----
chomp.Eol()(`Hello, World!\nIt's a great day!`)
----
|
....
rem: "It's a great day!"
ext: "Hello, World!"
....
|===

== Predicate combinators

TODO

[%header,cols="1a,1a,1a"]
|===
|Combinator
|Usage
|Output

|
https://pkg.go.dev/github.com/purpleclay/chomp#While[While]

Will scan the input text, testing each character against the provided predicate. Everything until the predicate returns false will be matched. A minimum of one character must be returned
|
[source,go]
----
chomp.While(chomp.IsLetter)("Hello, World!")
----
|
....
rem: ", World!"
ext: "Hello"
....

|
https://pkg.go.dev/github.com/purpleclay/chomp#WhileN[WhileN]

Will scan the input text, testing each character against the provided predicate. Everything until the predicate returns false will be matched. A minimum of `n` characters must be returned. If `n` is zero, this becomes an [.underline]#optional combinator#
|
[source,go]
----
chomp.WhileN(chomp.IsLetter, 1)("Hello, World!")
----
|
....
rem: ", World!"
ext: "Hello"
....

|
https://pkg.go.dev/github.com/purpleclay/chomp#WhileNM[WhileNM]

Will scan the input text, testing each character against the provided predicate. Everything until the predicate returns false will be matched. A minimum of `n` and upto a maximum of `m` characters must be returned. If `n` is zero, this becomes an [.underline]#optional combinator#
|
[source,go]
----
chomp.WhileNM(
    chomp.IsLetter, 1, 8)("Hello, World!")
----
|
....
rem: ", World!"
ext: "Hello"
....

|
https://pkg.go.dev/github.com/purpleclay/chomp#WhileNot[WhileNot]

Will scan the input text, testing each character against the provided predicate. Everything until the predicate returns true will be matched. This is the inverse of [While]. A minimum of one character must be returned.
|
[source,go]
----
chomp.WhileNot(chomp.IsDigit)("Hello, World!")
----
|
....
rem: ""
ext: "Hello, World!"
....

|
https://pkg.go.dev/github.com/purpleclay/chomp#WhileNotN[WhileNotN]

Will scan the input text, testing each character against the provided predicate. Everything until the predicate returns true will be matched. This is the inverse of [WhileN]. A minimum of `n` characters must be returned. If `n` is zero, this becomes an optional combinator
|
[source,go]
----
chomp.WhileNotN(
    chomp.IsDigit, 1)("Hello, World!")
----
|
....
rem: ""
ext: "Hello, World!"
....

|
https://pkg.go.dev/github.com/purpleclay/chomp#WhileNotNM[WhileNotNM]

Will scan the input text, testing each character against the provided predicate. Everything until the predicate returns true will be matched. This is the inverse of [WhileNM]. A minimum of `n` and upto a maximum of `m` characters must be returned. If `n` is zero, this becomes an optional combinator
|
[source,go]
----
chomp.WhileNotNM(
    chomp.IsLetter, 1, 8,
)("20240709 was a great day")
----
|
....
rem: " was a great day"
ext: "20240709"
....
|===

=== Available predicates

TODO

== Sequence combinators

TODO

[%header,cols="1a,1a,1a"]
|===
|Combinator
|Usage
|Output

|
https://pkg.go.dev/github.com/purpleclay/chomp#Pair[Pair]

Will scan the input text and match each combinator in turn. Both combinators must match. The result of each will be returned in the slice in execution order
|
[source,go]
----
chomp.Pair(
    chomp.Tag("Hello,"),
    chomp.Tag(" World"))("Hello, World!")
----
|
....
rem: "!"
ext: ["Hello,", " World"]
....

|
https://pkg.go.dev/github.com/purpleclay/chomp#SepPair[SepPair]

Will scan the input text and match each combinator in turn. All combinators must match. The result of the separator combinator is discarded and not included within the returned slice.
|
[source,go]
----
chomp.SepPair(
    chomp.Tag("Hello"),
    chomp.Tag(", "),
    chomp.Tag("World"))("Hello, World!")
----
|
....
rem: "!"
ext: ["Hello", "World"]
....

|
https://pkg.go.dev/github.com/purpleclay/chomp#Repeat[Repeat]

Will scan the input text and repeat the [Combinator] the defined number of times. Each combinator must match, with the output of each contained in the returned slice
|
[source,go]
----
chomp.Repeat(
    chomp.Parentheses(), 2,
)("(Hello)(World)(!)")
----
|
....
rem: "(!)"
ext: ["(Hello)", "(World)"]
....

|
https://pkg.go.dev/github.com/purpleclay/chomp#RepeatRange[RepeatRange]

Will scan the input text and repeat the [Combinator] between a minimum and maximum number of times. Each combinator must match, with the output of each contained in the returned slice. The minimum number of times must be executed for this combinator to be successful
|
[source,go]
----
chomp.RepeatRange(
    chomp.OneOf("Hleo"), 1, 8,
)("Hello, World!")
----
|
....
rem: ", World!"
ext: ["H", "e", "l", "l", "o"]
....

|
https://pkg.go.dev/github.com/purpleclay/chomp#Delimited[Delimited]

Will match a series of combinators against the input text. The left and right combinators are used to match a delimited sequence and are discarded. Only the text between the delimiters is extracted
|
[source,go]
----
chomp.Delimited(
    chomp.Tag("'"),
    chomp.Tag("Hello, World!"),
    chomp.Tag("'"))("'Hello, World!'")
----
|
....
rem: ""
ext: "Hello, World!"
....

|
https://pkg.go.dev/github.com/purpleclay/chomp#QuoteDouble[QuoteDouble]

Will match any text delimited (or surrounded) by a pair of "double quotes". The delimiters are discarded
|
[source,go]
----
chomp.DoubleQuote()(`"Hello, World!"`)
----
|
....
rem: ""
ext: "Hello, World!"
....

|
https://pkg.go.dev/github.com/purpleclay/chomp#QuoteSingle[QuoteSingle]

Will match any text delimited (or surrounded) by a pair of 'single quotes'. The delimiters are discarded
|
[source,go]
----
chomp.QuoteSingle()("'Hello, World!'")
----
|
....
rem: ""
ext: "Hello, World!"
....

|
https://pkg.go.dev/github.com/purpleclay/chomp#BracketSquare[BracketSquare]

Will match any text delimited (or surrounded) by a pair of [square brackets]. The delimiters are discarded
|
[source,go]
----
chomp.BracketSquare()("[Hello, World!]")
----
|
....
rem: ""
ext: "Hello, World!"
....

|
https://pkg.go.dev/github.com/purpleclay/chomp#Parentheses[Parentheses]

Will match any text delimited (or surrounded) by a pair of (parentheses). The delimiters are discarded
|
[source,go]
----
chomp.Parentheses()("(Hello, World!)")
----
|
....
rem: ""
ext: "Hello, World!"
....

|
https://pkg.go.dev/github.com/purpleclay/chomp#BracketAngled[BracketAngled]

Will match any text delimited (or surrounded) by a pair of <angled brackets>. The delimiters are discarded
|
[source,go]
----
chomp.BracketAngled()("<Hello, World!>")
----
|
....
rem: ""
ext: "Hello, World!"
....

|
https://pkg.go.dev/github.com/purpleclay/chomp#First[First]

Will match the input text against a series of combinators. Matching stops as soon as the first combinator succeeds. One combinator must match. For better performance, try and order the combinators from most to least likely to match
|
[source,go]
----
chomp.First(
    chomp.Tag("Good Morning"),
    chomp.Tag("Hello"),
)("Good Morning, World!")
----
|
....
rem: " ,World!"
ext: "Good Morning"
....

|
https://pkg.go.dev/github.com/purpleclay/chomp#All[All]

Will match the input text against a series of combinators. All combinators must match in the order provided
|
[source,go]
----
chomp.All(
    chomp.Tag("Hello"),
    chomp.Until("W"),
    chomp.Tag("World!"))("Hello, World!")
----
|
....
rem: ""
ext: ["Hello", ", ", "World!"]
....

|
https://pkg.go.dev/github.com/purpleclay/chomp#Many[Many]

Will scan the input text and match the [Combinator] a minimum of one time. The combinator will repeatedly be executed until the the first failed match. This is the equivalent of calling [ManyN] with an argument of 1
|
[source,go]
----
chomp.Many(one.Of("Ho"))("Hello, World!")
----
|
....
rem: "ello, World!"
ext: ["H"]
....

|
https://pkg.go.dev/github.com/purpleclay/chomp#ManyN[ManyN]

Will scan the input text and match the [Combinator] a minimum number of times. The combinator will repeatedly be executed until the first failed match. The minimum number of times must be executed for this combinator to be successful
|
[source,go]
----
chomp.ManyN(
    chomp.OneOf("W"), 0)("Hello, World!")
----
|
....
rem: "Hello, World!"
ext: []
....
|===
