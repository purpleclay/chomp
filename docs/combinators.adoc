= Available combinators and how to use them
:hardbreaks-option:

A glossary of all combinators available within `chomp` and their intended use.

- <<basic_combinators>>

== Basic combinators [[basic_combinators]]

[%header,cols="1a,1a,1a"]
|===
|Combinator
|Usage
|Output

|
https://pkg.go.dev/github.com/purpleclay/chomp#Tag[Tag]

Must match a series of characters at the beginning of the input text, in the exact order and case provided
|
[source,go]
----
chomp.Tag("Hello")("Hello, World!")
----
|
....
rem: ", World!"
ext: "Hello"
....

|
https://pkg.go.dev/github.com/purpleclay/chomp#Any[Any]

Must match at least one character at the beginning of the input text, from the provided sequence. Parsing immediately stops upon the first unmatched character
|
[source,go]
----
chomp.Any("eH")("Hello, World!")
----
|
....
rem: "llo, World!"
ext: "He"
....

|
https://pkg.go.dev/github.com/purpleclay/chomp#Not[Not]

Must not match at least one character at the beginning of the input text from the provided sequence. Parsing immediately stops upon the first matched character
|
[source,go]
----
chomp.Not("ol")("Hello, World!")
----
|
....
rem: "llo, World!"
ext: "He"
....

|
https://pkg.go.dev/github.com/purpleclay/chomp#OneOf[OneOf]

Must match a single character at the beginning of the text from the provided sequence
|
[source,go]
----
chomp.OneOf("!,eH")("Hello, World!")
----
|
....
rem: "ello, World!"
ext: "H"
....

|
https://pkg.go.dev/github.com/purpleclay/chomp#NoneOf[NoneOf]

Must not match a single character at the beginning of the text from the provided sequence
|
[source,go]
----
chomp.NoneOf("loWrd!e")("Hello, World!")
----
|
....
rem: "ello, World!"
ext: "H"
....

|
https://pkg.go.dev/github.com/purpleclay/chomp#Until[Until]

Will scan the input text for the first occurrence of the provided series of characters. Everything until that point in the text will be matched
|
[source,go]
----
chomp.Until("World")("Hello, World!")
----
|
....
rem: "World!"
ext: "Hello, "
....
|===

== Predicate combinators

[%header,cols="1a,1a,1a"]
|===
|Combinator
|Usage
|Output

|
https://pkg.go.dev/github.com/purpleclay/chomp#While[While]

Will scan the input text, testing each character against the provided predicate. Everything until the predicate returns false will be matched. A minimum of one character must be returned
|
[source,go]
----
chomp.While(chomp.IsLetter)("Hello, World!")
----
|
....
rem: ", World!"
ext: "Hello"
....

|
https://pkg.go.dev/github.com/purpleclay/chomp#WhileN[WhileN]

Will scan the input text, testing each character against the provided predicate. Everything until the predicate returns false will be matched. A minimum of `n` characters must be returned. If `n` is zero, this becomes an [.underline]#optional combinator#
|
[source,go]
----
chomp.WhileN(chomp.IsLetter, 1)("Hello, World!")
----
|
....
rem: ", World!"
ext: "Hello"
....

|
https://pkg.go.dev/github.com/purpleclay/chomp#WhileNM[WhileNM]

Will scan the input text, testing each character against the provided predicate. Everything until the predicate returns false will be matched. A minimum of `n` and upto a maximum of `m` characters must be returned. If `n` is zero, this becomes an [.underline]#optional combinator#
|
[source,go]
----
chomp.WhileNM(
    chomp.IsLetter, 1, 8)("Hello, World!")
----
|
....
rem: ", World!"
ext: "Hello"
....

|
https://pkg.go.dev/github.com/purpleclay/chomp#WhileNot[WhileNot]

Will scan the input text, testing each character against the provided predicate. Everything until the predicate returns true will be matched. This is the inverse of [While]. A minimum of one character must be returned.
|
[source,go]
----
chomp.WhileNot(chomp.IsDigit)("Hello, World!")
----
|
....
rem: ""
ext: "Hello, World!"
....

|
https://pkg.go.dev/github.com/purpleclay/chomp#WhileNotN[WhileNotN]

Will scan the input text, testing each character against the provided predicate. Everything until the predicate returns true will be matched. This is the inverse of [WhileN]. A minimum of `n` characters must be returned. If `n` is zero, this becomes an optional combinator
|
[source,go]
----
chomp.WhileNotN(
    chomp.IsDigit, 1)("Hello, World!")
----
|
....
rem: ""
ext: "Hello, World!"
....

|
https://pkg.go.dev/github.com/purpleclay/chomp#WhileNotNM[WhileNotNM]

Will scan the input text, testing each character against the provided predicate. Everything until the predicate returns true will be matched. This is the inverse of [WhileNM]. A minimum of `n` and upto a maximum of `m` characters must be returned. If `n` is zero, this becomes an optional combinator
|
[source,go]
----
chomp.WhileNotNM(
    chomp.IsLetter, 1, 8,
)("20240709 was a great day")
----
|
....
rem: " was a great day"
ext: "20240709"
....
|===

=== Available predicates

- `https://pkg.go.dev/github.com/purpleclay/chomp#pkg-variables:[IsDigit]`: Determines whether a rune is a decimal digit. A rune is classed as a digit if it is between the ASCII range of `'0'` or `'9'`, or it belongs within the Unicode https://www.fileformat.info/info/unicode/category/Nd/list.htm[Nd] category.
- `https://pkg.go.dev/github.com/purpleclay/chomp#pkg-variables:[IsLetter]`: Determines whether a rune is a letter. A rune is classed as a letter if it is between the ASCII range of `'a'` and `'z'` (_including its uppercase equivalents_), or it belongs within any of the Unicode letter categories: https://www.fileformat.info/info/unicode/category/Lu/list.htm[Lu] https://www.fileformat.info/info/unicode/category/Ll/list.htm[LI] https://www.fileformat.info/info/unicode/category/Lt/list.htm[Lt] https://www.fileformat.info/info/unicode/category/Lm/list.htm[Lm] https://www.fileformat.info/info/unicode/category/Lo/list.htm[Lo].
- `https://pkg.go.dev/github.com/purpleclay/chomp#pkg-variables:[IsAlphanumeric]`: Determines whether a rune is either a decimal digit or a letter. This is a convenience method that wraps both the existing `IsDigit` and `IsLetter` predicates.
- `https://pkg.go.dev/github.com/purpleclay/chomp#pkg-variables:[IsLineEnding]`: deterines whether a rune is one of the following ASCII line ending characters `'\r'` or `'\n'`.

== Sequence combinators

[%header,cols="1a,1a,1a"]
|===
|Combinator
|Usage
|Output

|
https://pkg.go.dev/github.com/purpleclay/chomp#Pair[Pair]

Will scan the input text and match each combinator in turn. Both combinators must match. The result of each will be returned in the slice in execution order
|
[source,go]
----
chomp.Pair(
    chomp.Tag("Hello,"),
    chomp.Tag(" World"))("Hello, World!")
----
|
....
rem: "!"
ext: ["Hello,", " World"]
....

|
https://pkg.go.dev/github.com/purpleclay/chomp#SepPair[SepPair]

Will scan the input text and match each combinator in turn. All combinators must match. The result of the separator combinator is discarded and not included within the returned slice.
|
[source,go]
----
chomp.SepPair(
    chomp.Tag("Hello"),
    chomp.Tag(", "),
    chomp.Tag("World"))("Hello, World!")
----
|
....
rem: "!"
ext: ["Hello", "World"]
....

|
https://pkg.go.dev/github.com/purpleclay/chomp#Repeat[Repeat]

Will scan the input text and repeat the [Combinator] the defined number of times. Each combinator must match, with the output of each contained in the returned slice
|
[source,go]
----
chomp.Repeat(
    chomp.Parentheses(), 2,
)("(Hello)(World)(!)")
----
|
....
rem: "(!)"
ext: ["(Hello)", "(World)"]
....

|
https://pkg.go.dev/github.com/purpleclay/chomp#RepeatRange[RepeatRange]

Will scan the input text and repeat the [Combinator] between a minimum and maximum number of times. Each combinator must match, with the output of each contained in the returned slice. The minimum number of times must be executed for this combinator to be successful
|
[source,go]
----
chomp.RepeatRange(
    chomp.OneOf("Hleo"), 1, 8,
)("Hello, World!")
----
|
....
rem: ", World!"
ext: ["H", "e", "l", "l", "o"]
....

|
https://pkg.go.dev/github.com/purpleclay/chomp#Delimited[Delimited]

Will match a series of combinators against the input text. The left and right combinators are used to match a delimited sequence and are discarded. Only the text between the delimiters is extracted
|
[source,go]
----
chomp.Delimited(
    chomp.Tag("'"),
    chomp.Tag("Hello, World!"),
    chomp.Tag("'"))("'Hello, World!'")
----
|
....
rem: ""
ext: "Hello, World!"
....

|
https://pkg.go.dev/github.com/purpleclay/chomp#QuoteDouble[QuoteDouble]

Will match any text delimited (or surrounded) by a pair of "double quotes". The delimiters are discarded
|
[source,go]
----
chomp.DoubleQuote()(`"Hello, World!"`)
----
|
....
rem: ""
ext: "Hello, World!"
....

|
https://pkg.go.dev/github.com/purpleclay/chomp#QuoteSingle[QuoteSingle]

Will match any text delimited (or surrounded) by a pair of 'single quotes'. The delimiters are discarded
|
[source,go]
----
chomp.QuoteSingle()("'Hello, World!'")
----
|
....
rem: ""
ext: "Hello, World!"
....

|
https://pkg.go.dev/github.com/purpleclay/chomp#BracketSquare[BracketSquare]

Will match any text delimited (or surrounded) by a pair of [square brackets]. The delimiters are discarded
|
[source,go]
----
chomp.BracketSquare()("[Hello, World!]")
----
|
....
rem: ""
ext: "Hello, World!"
....

|
https://pkg.go.dev/github.com/purpleclay/chomp#Parentheses[Parentheses]

Will match any text delimited (or surrounded) by a pair of (parentheses). The delimiters are discarded
|
[source,go]
----
chomp.Parentheses()("(Hello, World!)")
----
|
....
rem: ""
ext: "Hello, World!"
....

|
https://pkg.go.dev/github.com/purpleclay/chomp#BracketAngled[BracketAngled]

Will match any text delimited (or surrounded) by a pair of <angled brackets>. The delimiters are discarded
|
[source,go]
----
chomp.BracketAngled()("<Hello, World!>")
----
|
....
rem: ""
ext: "Hello, World!"
....

|
https://pkg.go.dev/github.com/purpleclay/chomp#First[First]

Will match the input text against a series of combinators. Matching stops as soon as the first combinator succeeds. One combinator must match. For better performance, try and order the combinators from most to least likely to match
|
[source,go]
----
chomp.First(
    chomp.Tag("Good Morning"),
    chomp.Tag("Hello"),
)("Good Morning, World!")
----
|
....
rem: " ,World!"
ext: "Good Morning"
....

|
https://pkg.go.dev/github.com/purpleclay/chomp#All[All]

Will match the input text against a series of combinators. All combinators must match in the order provided
|
[source,go]
----
chomp.All(
    chomp.Tag("Hello"),
    chomp.Until("W"),
    chomp.Tag("World!"))("Hello, World!")
----
|
....
rem: ""
ext: ["Hello", ", ", "World!"]
....

|
https://pkg.go.dev/github.com/purpleclay/chomp#Many[Many]

Will scan the input text and match the [Combinator] a minimum of one time. The combinator will repeatedly be executed until the the first failed match. This is the equivalent of calling [ManyN] with an argument of 1
|
[source,go]
----
chomp.Many(one.Of("Ho"))("Hello, World!")
----
|
....
rem: "ello, World!"
ext: ["H"]
....

|
https://pkg.go.dev/github.com/purpleclay/chomp#ManyN[ManyN]

Will scan the input text and match the [Combinator] a minimum number of times. The combinator will repeatedly be executed until the first failed match. The minimum number of times must be executed for this combinator to be successful
|
[source,go]
----
chomp.ManyN(
    chomp.OneOf("W"), 0)("Hello, World!")
----
|
....
rem: "Hello, World!"
ext: []
....

|https://pkg.go.dev/github.com/purpleclay/chomp#Prefixed[Prefixed]

Will firstly scan the input text for a defined prefix and discard it. The remaining input text will be matched against the [Combinator] and returned if successful. Both combinators must match
|
[source,go]
----
chomp.Prefixed(
    chomp.Tag("Hello"),
    chomp.Tag(`"`))(`"Hello, World!"`)
----
|
....
rem: `, World!"`
ext: "Hello"
....

|https://pkg.go.dev/github.com/purpleclay/chomp#Suffixed[Suffixed]

Will firstly scan the input text and match it against the [Combinator]. The remaining text will be scanned for a defined suffix and discarded. Both combinators must match
|
[source,go]
----
chomp.Suffixed(
    chomp.Tag("Hello"),
    chomp.Tag(", "))("Hello, World!")
----
|
....
rem: "World!"
ext: "Hello"
....
|===

== Modifier combinators

[%header,cols="1a,1a,1a"]
|===
|Combinator
|Usage
|Output

|https://pkg.go.dev/github.com/purpleclay/chomp#Map[Map]

Map the result of a [Combinator] to any other type
|
[source,go]
----
chomp.Map(
    chomp.While(chomp.IsDigit),
    func (in string) int {
        return len(in)
    },
)("123456")
----
|
....
rem: ""
ext: 6
....

|https://pkg.go.dev/github.com/purpleclay/chomp#S[S]

Wraps the result of the inner combinator within a string slice. Combinators of differing return types can be successfully chained together while using this conversion combinator
|
[source,go]
----
chomp.S(chomp.Until(","))("Hello, World!")
----
|
....
rem: ", World!"
ext: ["Hello"]
....

|https://pkg.go.dev/github.com/purpleclay/chomp#I[I]

Extracts and returns a single string from the result of the inner combinator. Combinators of differing return types can be successfully chained together while using this conversion combinator
|
[source,go]
----
chomp.I(chomp.SepPair(
    chomp.Tag("Hello"),
    chomp.Tag(", "),
    chomp.Tag("World")), 1)("Hello, World!")
----
|
....
rem: "!"
ext: "World"
....

|https://pkg.go.dev/github.com/purpleclay/chomp#Peek[Peek]

Will scan the text and apply the parser without consuming any of the input. Useful if you need to lookahead
|
[source,go]
----
chomp.Peek(chomp.Tag("Hello"))("Hello, World!")
----
|
....
rem: "Hello, World!"
ext: "Hello"
....

|https://pkg.go.dev/github.com/purpleclay/chomp#Opt[Opt]

Allows a combinator to be optional. Any error returned by the underlying combinator will be swallowed. The parsed text will not be modified if the underlying combinator did not run
|
[source,go]
----
chomp.Opt(chomp.Tag("Hey"))("Hello, World!")
----
|
....
rem: "Hello, World!"
ext: ""
....
|===

== Ready-made parsers

[%header,cols="1a,1a,1a"]
|===
|Combinator
|Usage
|Output

|
https://pkg.go.dev/github.com/purpleclay/chomp#Crlf[Crlf]

Must match either a `CR (\r)` or `CRLF (\r\n)` line ending
|
[source,go]
----
chomp.Crlf()("\r\nHello")
----
|
....
rem: "Hello"
ext: "\r\n"
....

|
https://pkg.go.dev/github.com/purpleclay/chomp#Eol[Eol]

Will scan the text until it encounters any ASCII line ending characters identified by the [IsLineEnding] predicate. All text before the line ending will be returned. The line ending, if detected, will be discarded
|
[source,go]
----
chomp.Eol()(`Hello, World!\nIt's a great day!`)
----
|
....
rem: "It's a great day!"
ext: "Hello, World!"
....
|===
